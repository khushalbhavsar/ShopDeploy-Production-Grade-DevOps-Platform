/**
 * ============================================================================
 * ShopDeploy CI Pipeline (Build Once, Deploy Many)
 * ============================================================================
 * Responsibilities:
 * - Checkout code
 * - Install dependencies
 * - Run lint + tests
 * - SonarQube analysis + Quality Gate
 * - Security scan (Trivy)
 * - Build Docker images
 * - Push to ECR
 * - Save image tag & trigger CD pipeline
 * ============================================================================
 */

pipeline {
    // ğŸ”¥ Run on Jenkins agent with Docker installed
    agent any

    environment {
        // AWS Configuration
        AWS_REGION = 'us-east-1'
        AWS_ACCOUNT_ID = credentials('aws-account-id')

        // ECR Configuration
        ECR_REGISTRY = "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
        ECR_BACKEND_REPO = "shopdeploy-prod-backend"
        ECR_FRONTEND_REPO = "shopdeploy-prod-frontend"

        // Image Tag (immutable - BUILD_NUMBER + commit hash)
        IMAGE_TAG = "${BUILD_NUMBER}-${GIT_COMMIT.take(7)}"

        // SonarQube Configuration
        SONAR_PROJECT_KEY = 'shopdeploy'

        // Directory Paths
        BACKEND_DIR = 'shopdeploy-backend'
        FRONTEND_DIR = 'shopdeploy-frontend'
    }

    tools {
        nodejs 'NodeJS-18'
    }

    options {
        timeout(time: 45, unit: 'MINUTES')
        buildDiscarder(logRotator(numToKeepStr: '20'))
        disableConcurrentBuilds()
        timestamps()
    }

    parameters {
        booleanParam(
            name: 'SKIP_TESTS',
            defaultValue: false,
            description: 'Skip running unit tests'
        )
        booleanParam(
            name: 'SKIP_SONAR',
            defaultValue: false,
            description: 'Skip SonarQube analysis'
        )
        booleanParam(
            name: 'RUN_SECURITY_SCAN',
            defaultValue: true,
            description: 'Run Docker image security scan'
        )
        booleanParam(
            name: 'TRIGGER_CD',
            defaultValue: true,
            description: 'Trigger CD pipeline after successful build'
        )
        choice(
            name: 'TARGET_ENVIRONMENT',
            choices: ['dev', 'staging', 'prod'],
            description: 'Target environment for CD pipeline'
        )
    }

    triggers {
        githubPush()
    }

    stages {
        //======================================================================
        // Stage 1: Checkout Source Code
        //======================================================================
        stage('Checkout') {
            steps {
                echo 'ğŸ”„ Checking out source code...'
                checkout scm
                
                script {
                    env.GIT_COMMIT_MSG = sh(
                        script: 'git log -1 --pretty=%B',
                        returnStdout: true
                    ).trim()
                    env.GIT_AUTHOR = sh(
                        script: 'git log -1 --pretty=%an',
                        returnStdout: true
                    ).trim()
                    
                    echo "ğŸ“ Commit: ${env.GIT_COMMIT_MSG}"
                    echo "ğŸ‘¤ Author: ${env.GIT_AUTHOR}"
                    echo "ğŸ·ï¸ Image Tag: ${IMAGE_TAG}"
                }
            }
        }

        //======================================================================
        // Stage 2: Detect Changes
        //======================================================================
        stage('Detect Changes') {
            steps {
                script {
                    echo 'ğŸ” Detecting code changes...'
                    
                    def backendChanges = sh(
                        script: "git diff --name-only HEAD~1 HEAD -- ${BACKEND_DIR}/ || echo 'initial'",
                        returnStdout: true
                    ).trim()
                    
                    def frontendChanges = sh(
                        script: "git diff --name-only HEAD~1 HEAD -- ${FRONTEND_DIR}/ || echo 'initial'",
                        returnStdout: true
                    ).trim()
                    
                    env.BACKEND_CHANGED = (backendChanges != '') ? 'true' : 'false'
                    env.FRONTEND_CHANGED = (frontendChanges != '') ? 'true' : 'false'
                    
                    echo "ğŸ“¦ Backend changed: ${env.BACKEND_CHANGED}"
                    echo "ğŸ¨ Frontend changed: ${env.FRONTEND_CHANGED}"
                }
            }
        }

        //======================================================================
        // Stage 3: Install Dependencies
        //======================================================================
        stage('Install Dependencies') {
            parallel {
                stage('Backend Dependencies') {
                    steps {
                        dir("${BACKEND_DIR}") {
                            echo 'ğŸ“¦ Installing backend dependencies...'
                            sh '''
                                npm ci --prefer-offline --no-audit
                                echo "âœ… Backend dependencies installed"
                            '''
                        }
                    }
                }

                stage('Frontend Dependencies') {
                    steps {
                        dir("${FRONTEND_DIR}") {
                            echo 'ğŸ“¦ Installing frontend dependencies...'
                            sh '''
                                npm ci --prefer-offline --no-audit
                                echo "âœ… Frontend dependencies installed"
                            '''
                        }
                    }
                }
            }
        }

        //======================================================================
        // Stage 4: Code Linting
        //======================================================================
        stage('Code Linting') {
            parallel {
                stage('Backend Lint') {
                    steps {
                        dir("${BACKEND_DIR}") {
                            echo 'ğŸ” Linting backend code...'
                            sh 'npm run lint || echo "âš ï¸ Lint warnings found"'
                        }
                    }
                }

                stage('Frontend Lint') {
                    steps {
                        dir("${FRONTEND_DIR}") {
                            echo 'ğŸ” Linting frontend code...'
                            sh 'npm run lint || echo "âš ï¸ Lint warnings found"'
                        }
                    }
                }
            }
        }

        //======================================================================
        // Stage 5: Unit Tests
        //======================================================================
        stage('Unit Tests') {
            when {
                expression { !params.SKIP_TESTS }
            }
            parallel {
                stage('Backend Tests') {
                    steps {
                        dir("${BACKEND_DIR}") {
                            echo 'ğŸ§ª Running backend tests...'
                            sh 'npm test -- --coverage --passWithNoTests || echo "âš ï¸ Some tests failed"'
                        }
                    }
                    post {
                        always {
                            junit allowEmptyResults: true, testResults: "${BACKEND_DIR}/coverage/junit.xml"
                        }
                    }
                }

                stage('Frontend Tests') {
                    steps {
                        dir("${FRONTEND_DIR}") {
                            echo 'ğŸ§ª Running frontend tests...'
                            sh 'npm test -- --coverage --passWithNoTests || echo "âš ï¸ Some tests failed"'
                        }
                    }
                    post {
                        always {
                            junit allowEmptyResults: true, testResults: "${FRONTEND_DIR}/coverage/junit.xml"
                        }
                    }
                }
            }
        }

        //======================================================================
        // Stage 6: SonarQube Analysis
        //======================================================================
        stage('SonarQube Analysis') {
            when {
                expression { params.SKIP_SONAR == false }
            }
            steps {
                echo 'ğŸ“Š Running SonarQube analysis...'
                withSonarQubeEnv('SonarQube') {
                    sh """
                        sonar-scanner \
                            -Dsonar.projectKey=${SONAR_PROJECT_KEY} \
                            -Dsonar.projectName=ShopDeploy \
                            -Dsonar.sources=. \
                            -Dsonar.exclusions=node_modules/**,**/test/**,**/coverage/**,**/*.spec.js \
                            -Dsonar.javascript.lcov.reportPaths=${BACKEND_DIR}/coverage/lcov.info,${FRONTEND_DIR}/coverage/lcov.info
                    """
                }
            }
        }

        //======================================================================
        // Stage 7: Quality Gate
        //======================================================================
        stage('Quality Gate') {
            when {
                expression { params.SKIP_SONAR == false }
            }
            steps {
                echo 'ğŸš¦ Checking Quality Gate...'
                timeout(time: 5, unit: 'MINUTES') {
                    waitForQualityGate abortPipeline: true
                }
            }
        }

        //======================================================================
        // Stage 8: Build Docker Images
        //======================================================================
        stage('Build Docker Images') {
            parallel {
                stage('Build Backend Image') {
                    steps {
                        echo 'ğŸ³ Building backend Docker image...'
                        withCredentials([[
                            $class: 'AmazonWebServicesCredentialsBinding',
                            credentialsId: 'aws-credentials',
                            accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                            secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                        ]]) {
                            sh """
                                # Login to ECR for cache pull
                                aws ecr get-login-password --region ${AWS_REGION} | \
                                    docker login --username AWS --password-stdin ${ECR_REGISTRY}
                                
                                # Pull latest image for cache (ignore if not exists)
                                docker pull ${ECR_REGISTRY}/${ECR_BACKEND_REPO}:latest || true
                                
                                docker build \
                                    --cache-from ${ECR_REGISTRY}/${ECR_BACKEND_REPO}:latest \
                                    --tag shopdeploy-backend:${IMAGE_TAG} \
                                    --build-arg BUILD_DATE=\$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
                                    --build-arg VERSION=${IMAGE_TAG} \
                                    --build-arg BUILDKIT_INLINE_CACHE=1 \
                                    --file ${BACKEND_DIR}/Dockerfile \
                                    ${BACKEND_DIR}
                            """
                        }
                    }
                }

                stage('Build Frontend Image') {
                    steps {
                        echo 'ğŸ³ Building frontend Docker image...'
                        withCredentials([[
                            $class: 'AmazonWebServicesCredentialsBinding',
                            credentialsId: 'aws-credentials',
                            accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                            secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                        ]]) {
                            script {
                                // Build with dev API URL - environment-specific URLs are set at deploy time
                                def apiUrl = "https://api-${params.TARGET_ENVIRONMENT}.shopdeploy.com/api"
                                if (params.TARGET_ENVIRONMENT == 'prod') {
                                    apiUrl = 'https://api.shopdeploy.com/api'
                                }
                                
                                sh """
                                    # Pull latest image for cache (ignore if not exists)
                                    docker pull ${ECR_REGISTRY}/${ECR_FRONTEND_REPO}:latest || true
                                    
                                    docker build \
                                        --cache-from ${ECR_REGISTRY}/${ECR_FRONTEND_REPO}:latest \
                                        --tag shopdeploy-frontend:${IMAGE_TAG} \
                                        --build-arg BUILD_DATE=\$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
                                        --build-arg VERSION=${IMAGE_TAG} \
                                        --build-arg VITE_API_URL=${apiUrl} \
                                        --build-arg BUILDKIT_INLINE_CACHE=1 \
                                        --file ${FRONTEND_DIR}/Dockerfile \
                                        ${FRONTEND_DIR}
                                """
                            }
                        }
                    }
                }
            }
        }

        //======================================================================
        // Stage 9: Security Scan (Trivy)
        //======================================================================
        stage('Security Scan') {
            when {
                expression { params.RUN_SECURITY_SCAN }
            }
            parallel {
                stage('Scan Backend Image') {
                    steps {
                        echo 'ğŸ”’ Scanning backend image for vulnerabilities...'
                        sh '''
                            if command -v trivy &> /dev/null; then
                                trivy image --severity HIGH,CRITICAL --exit-code 0 --format table shopdeploy-backend:${IMAGE_TAG} || true
                            else
                                echo "âš ï¸ Trivy not available. Skipping security scan."
                            fi
                        '''
                    }
                }

                stage('Scan Frontend Image') {
                    steps {
                        echo 'ğŸ”’ Scanning frontend image for vulnerabilities...'
                        sh '''
                            if command -v trivy &> /dev/null; then
                                trivy image --severity HIGH,CRITICAL --exit-code 0 --format table shopdeploy-frontend:${IMAGE_TAG} || true
                            else
                                echo "âš ï¸ Trivy not available. Skipping security scan."
                            fi
                        '''
                    }
                }
            }
        }

        //======================================================================
        // Stage 10: Push to ECR
        //======================================================================
        stage('Push to ECR') {
            steps {
                echo 'ğŸš€ Pushing images to AWS ECR...'
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'aws-credentials',
                    accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                    secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                ]]) {
                    sh '''
                        # Login to ECR
                        aws ecr get-login-password --region ${AWS_REGION} | \
                            docker login --username AWS --password-stdin ${ECR_REGISTRY}
                    '''
                    
                    // Push backend with retry
                    retry(3) {
                        sh '''
                            docker tag shopdeploy-backend:${IMAGE_TAG} ${ECR_REGISTRY}/${ECR_BACKEND_REPO}:${IMAGE_TAG}
                            docker push ${ECR_REGISTRY}/${ECR_BACKEND_REPO}:${IMAGE_TAG}
                            echo "âœ… Backend pushed: ${ECR_REGISTRY}/${ECR_BACKEND_REPO}:${IMAGE_TAG}"
                        '''
                    }
                    
                    // Push frontend with retry
                    retry(3) {
                        sh '''
                            docker tag shopdeploy-frontend:${IMAGE_TAG} ${ECR_REGISTRY}/${ECR_FRONTEND_REPO}:${IMAGE_TAG}
                            docker push ${ECR_REGISTRY}/${ECR_FRONTEND_REPO}:${IMAGE_TAG}
                            echo "âœ… Frontend pushed: ${ECR_REGISTRY}/${ECR_FRONTEND_REPO}:${IMAGE_TAG}"
                        '''
                    }
                }
            }
        }

        //======================================================================
        // Stage 11: Save Image Tag
        //======================================================================
        stage('Save Image Tag') {
            steps {
                echo 'ğŸ’¾ Saving image tag for CD pipeline...'
                script {
                    // Save to file for artifact
                    writeFile file: 'image-tag.txt', text: IMAGE_TAG
                    
                    // Save build metadata
                    def buildInfo = """
                    {
                        "imageTag": "${IMAGE_TAG}",
                        "buildNumber": "${BUILD_NUMBER}",
                        "gitCommit": "${GIT_COMMIT}",
                        "gitAuthor": "${env.GIT_AUTHOR}",
                        "gitMessage": "${env.GIT_COMMIT_MSG}",
                        "buildTime": "${new Date().format('yyyy-MM-dd HH:mm:ss')}",
                        "backendImage": "${ECR_REGISTRY}/${ECR_BACKEND_REPO}:${IMAGE_TAG}",
                        "frontendImage": "${ECR_REGISTRY}/${ECR_FRONTEND_REPO}:${IMAGE_TAG}"
                    }
                    """
                    writeFile file: 'build-info.json', text: buildInfo
                    
                    // Archive artifacts
                    archiveArtifacts artifacts: 'image-tag.txt,build-info.json', fingerprint: true
                    
                    // Optional: Store in AWS Parameter Store for cross-pipeline access
                    withCredentials([[
                        $class: 'AmazonWebServicesCredentialsBinding',
                        credentialsId: 'aws-credentials',
                        accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                        secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                    ]]) {
                        sh """
                            aws ssm put-parameter \
                                --name "/shopdeploy/latest-image-tag" \
                                --value "${IMAGE_TAG}" \
                                --type String \
                                --overwrite \
                                --region ${AWS_REGION} || echo "âš ï¸ Failed to update Parameter Store"
                        """
                    }
                    
                    echo "âœ… Image tag saved: ${IMAGE_TAG}"
                }
            }
        }

        //======================================================================
        // Stage 12: Cleanup
        //======================================================================
        stage('Cleanup') {
            steps {
                echo 'ğŸ§¹ Cleaning up local images...'
                sh """
                    docker rmi shopdeploy-backend:${IMAGE_TAG} || true
                    docker rmi shopdeploy-frontend:${IMAGE_TAG} || true
                    docker rmi ${ECR_REGISTRY}/${ECR_BACKEND_REPO}:${IMAGE_TAG} || true
                    docker rmi ${ECR_REGISTRY}/${ECR_FRONTEND_REPO}:${IMAGE_TAG} || true
                    docker image prune -f || true
                    echo "âœ… Cleanup completed"
                """
            }
        }
    }

    //==========================================================================
    // Post-Build Actions
    //==========================================================================
    post {
        success {
            script {
                echo """
                â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
                â•‘  âœ… CI PIPELINE COMPLETED SUCCESSFULLY                    â•‘
                â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
                â•‘  Build: #${BUILD_NUMBER}                                  
                â•‘  Image Tag: ${IMAGE_TAG}                                  
                â•‘  Duration: ${currentBuild.durationString}                 
                â•‘  Target Environment: ${params.TARGET_ENVIRONMENT}         
                â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                """
                
                // Slack notification (optional - skip if not configured)
                try {
                    slackSend(
                        channel: '#deployments',
                        color: 'good',
                        message: "âœ… CI Build Success | Build #${BUILD_NUMBER} | Tag: ${IMAGE_TAG} | Duration: ${currentBuild.durationString}"
                    )
                } catch (Exception e) {
                    echo "âš ï¸ Slack notification skipped (not configured)"
                }
                
                // Trigger CD pipeline if enabled
                if (params.TRIGGER_CD) {
                    echo "ğŸš€ Triggering CD pipeline for ${params.TARGET_ENVIRONMENT}..."
                    build job: 'shopdeploy-cd',
                        parameters: [
                            string(name: 'IMAGE_TAG', value: IMAGE_TAG),
                            string(name: 'ENVIRONMENT', value: params.TARGET_ENVIRONMENT)
                        ],
                        wait: false  // Don't wait for CD to complete
                }
            }
        }

        failure {
            script {
                echo """
                â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
                â•‘  âŒ CI PIPELINE FAILED                                    â•‘
                â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
                â•‘  Build: #${BUILD_NUMBER}                                  
                â•‘  Stage: ${env.STAGE_NAME}                                 
                â•‘  Check logs for details                                   
                â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                """
                
                // Slack notification (optional - skip if not configured)
                try {
                    slackSend(
                        channel: '#deployments',
                        color: 'danger',
                        message: "âŒ CI Build FAILED | Build #${BUILD_NUMBER} | Stage: ${env.STAGE_NAME} | <${BUILD_URL}|View Logs>"
                    )
                } catch (Exception e) {
                    echo "âš ï¸ Slack notification skipped (not configured)"
                }
            }
        }

        unstable {
            echo 'âš ï¸ CI Pipeline completed with warnings (unstable)'
            // Slack notification (optional - skip if not configured)
            script {
                try {
                    slackSend(
                        channel: '#deployments',
                        color: 'warning',
                        message: "âš ï¸ CI Build Unstable | Build #${BUILD_NUMBER} | Tag: ${IMAGE_TAG}"
                    )
                } catch (Exception e) {
                    echo "âš ï¸ Slack notification skipped (not configured)"
                }
            }
        }

        always {
            archiveArtifacts artifacts: '**/coverage/**', allowEmptyArchive: true
            
            cleanWs(
                cleanWhenNotBuilt: false,
                deleteDirs: true,
                disableDeferredWipeout: true,
                notFailBuild: true
            )
        }
    }
}
