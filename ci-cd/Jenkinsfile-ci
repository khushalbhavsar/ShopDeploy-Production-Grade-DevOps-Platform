/**
 * ============================================================================
 * ShopDeploy CI Pipeline (Build Once, Deploy Many)
 * ============================================================================
 * Responsibilities:
 * - Checkout code
 * - Install dependencies
 * - Run lint + tests
 * - SonarQube analysis + Quality Gate
 * - Security scan (Trivy)
 * - Build Docker images
 * - Push to ECR
 * - Save image tag & trigger CD pipeline
 * ============================================================================
 */

pipeline {
    // ğŸ”¥ Run on Jenkins agent with Docker installed
    agent any

    environment {
        // AWS Configuration
        AWS_REGION = 'us-east-1'
        AWS_ACCOUNT_ID = credentials('aws-account-id')

        // ECR Configuration
        ECR_REGISTRY = "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
        ECR_BACKEND_REPO = "shopdeploy-prod-backend"
        ECR_FRONTEND_REPO = "shopdeploy-prod-frontend"

        // Image Tag (immutable - BUILD_NUMBER + commit hash)
        IMAGE_TAG = "${BUILD_NUMBER}-${GIT_COMMIT.take(7)}"

        // SonarQube Configuration
        SONAR_PROJECT_KEY = 'shopdeploy'

        // Directory Paths
        BACKEND_DIR = 'shopdeploy-backend'
        FRONTEND_DIR = 'shopdeploy-frontend'
    }


    options {
        timeout(time: 45, unit: 'MINUTES')
        buildDiscarder(logRotator(numToKeepStr: '20'))
        disableConcurrentBuilds()
        timestamps()
    }

    parameters {
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ENVIRONMENT SELECTION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        choice(
            name: 'TARGET_ENVIRONMENT',
            choices: ['dev', 'staging', 'prod'],
            description: 'ğŸŒ Select deployment environment (REQUIRED)'
        )
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CD TRIGGER OPTIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        booleanParam(
            name: 'TRIGGER_CD',
            defaultValue: true,
            description: 'ğŸš€ Trigger CD pipeline after successful build'
        )
    }

    triggers {
        githubPush()
    }

    stages {
        //======================================================================
        // Stage 1: Environment Validation
        //======================================================================
        stage('Environment Setup') {
            steps {
                script {
                    // Display selected environment prominently
                    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    echo "ğŸŒ TARGET ENVIRONMENT: ${params.TARGET_ENVIRONMENT?.toUpperCase() ?: 'DEV'}"
                    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    
                    // Default environment if not set
                    def targetEnv = params.TARGET_ENVIRONMENT ?: 'dev'
                    
                    // Set environment-specific variables
                    if (targetEnv == 'prod') {
                        env.ENV_EMOJI = 'ğŸ”´'
                        env.API_URL = 'https://api.shopdeploy.com/api'
                        env.REQUIRE_APPROVAL = 'true'
                        echo "${env.ENV_EMOJI} PRODUCTION deployment - Extra validations enabled"
                    } else if (targetEnv == 'staging') {
                        env.ENV_EMOJI = 'ğŸŸ¡'
                        env.API_URL = 'https://api-staging.shopdeploy.com/api'
                        env.REQUIRE_APPROVAL = 'false'
                        echo "${env.ENV_EMOJI} STAGING deployment"
                    } else {
                        env.ENV_EMOJI = 'ğŸŸ¢'
                        env.API_URL = 'https://api-dev.shopdeploy.com/api'
                        env.REQUIRE_APPROVAL = 'false'
                        echo "${env.ENV_EMOJI} DEVELOPMENT deployment"
                    }
                    
                    // Block skipping tests in production
                    if (targetEnv == 'prod' && params.SKIP_TESTS) {
                        error("âŒ Cannot skip tests for PRODUCTION deployment!")
                    }
                    
                    // Display stage skip configuration
                    echo ""
                    echo "ğŸ› ï¸  STAGE CONFIGURATION:"
                    echo "    â”œâ”€ Skip Lint:          ${params.SKIP_LINT ? 'âœ… YES' : 'âŒ NO'}"
                    echo "    â”œâ”€ Skip Tests:         ${params.SKIP_TESTS ? 'âœ… YES' : 'âŒ NO'}"
                    echo "    â”œâ”€ Skip SonarQube:     ${params.SKIP_SONAR ? 'âœ… YES' : 'âŒ NO'}"
                    echo "    â”œâ”€ Skip Security Scan: ${params.SKIP_SECURITY_SCAN ? 'âœ… YES' : 'âŒ NO'}"
                    echo "    â””â”€ Trigger CD:         ${params.TRIGGER_CD ? 'âœ… YES' : 'âŒ NO'}"
                    echo ""
                    echo "API URL: ${env.API_URL}"
                    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                }
            }
        }

        //======================================================================
        // Stage 2: Checkout Source Code
        //======================================================================
        stage('Checkout') {
            steps {
                echo 'Checking out source code...'
                checkout scm
                
                script {
                    env.GIT_COMMIT_MSG = sh(
                        script: 'git log -1 --pretty=%B',
                        returnStdout: true
                    ).trim()
                    env.GIT_AUTHOR = sh(
                        script: 'git log -1 --pretty=%an',
                        returnStdout: true
                    ).trim()
                    
                    echo "Commit: ${env.GIT_COMMIT_MSG}"
                    echo "Author: ${env.GIT_AUTHOR}"
                    echo "Image Tag: ${IMAGE_TAG}"
                }
            }
        }

        //======================================================================
        // Stage 3: Detect Changes
        //======================================================================
        stage('Detect Changes') {
            steps {
                script {
                    echo 'Detecting code changes...'
                    
                    def backendChanges = sh(
                        script: "git diff --name-only HEAD~1 HEAD -- ${BACKEND_DIR}/ || echo 'initial'",
                        returnStdout: true
                    ).trim()
                    
                    def frontendChanges = sh(
                        script: "git diff --name-only HEAD~1 HEAD -- ${FRONTEND_DIR}/ || echo 'initial'",
                        returnStdout: true
                    ).trim()
                    
                    env.BACKEND_CHANGED = (backendChanges != '') ? 'true' : 'false'
                    env.FRONTEND_CHANGED = (frontendChanges != '') ? 'true' : 'false'
                    
                    echo "Backend changed: ${env.BACKEND_CHANGED}"
                    echo "Frontend changed: ${env.FRONTEND_CHANGED}"
                }
            }
        }

        //======================================================================
        // Stage 4: Install Dependencies
        //======================================================================
        stage('Install Dependencies') {
            parallel {
                stage('Backend Dependencies') {
                    steps {
                        dir("${BACKEND_DIR}") {
                            echo 'Installing backend dependencies...'
                            sh '''
                                npm ci --prefer-offline --no-audit
                                echo "Backend dependencies installed"
                            '''
                        }
                    }
                }

                stage('Frontend Dependencies') {
                    steps {
                        dir("${FRONTEND_DIR}") {
                            echo 'Installing frontend dependencies...'
                            sh '''
                                npm ci --prefer-offline --no-audit
                                echo "Frontend dependencies installed"
                            '''
                        }
                    }
                }
            }
        }

        //======================================================================
        // Stage 5: Code Linting
        //======================================================================
        stage('Code Linting') {
            parallel {
                stage('Backend Lint') {
                    steps {
                        dir("${BACKEND_DIR}") {
                            echo 'Linting backend code...'
                            sh 'npm run lint || echo "Lint warnings found"'
                        }
                    }
                }

                stage('Frontend Lint') {
                    steps {
                        dir("${FRONTEND_DIR}") {
                            echo 'Linting frontend code...'
                            sh 'npm run lint || echo "Lint warnings found"'
                        }
                    }
                }
            }
        }

        //======================================================================
        // Stage 6: Unit Tests
        //======================================================================
        stage('Unit Tests') {
            parallel {
                stage('Backend Tests') {
                    steps {
                        dir("${BACKEND_DIR}") {
                            echo 'Running backend tests...'
                            sh 'npm test -- --coverage --passWithNoTests || echo "Some tests failed"'
                        }
                    }
                    post {
                        always {
                            junit allowEmptyResults: true, testResults: "${BACKEND_DIR}/coverage/junit.xml"
                        }
                    }
                }

                stage('Frontend Tests') {
                    steps {
                        dir("${FRONTEND_DIR}") {
                            echo 'Running frontend tests...'
                            sh 'npm test -- --coverage --passWithNoTests || echo "Some tests failed"'
                        }
                    }
                    post {
                        always {
                            junit allowEmptyResults: true, testResults: "${FRONTEND_DIR}/coverage/junit.xml"
                        }
                    }
                }
            }
        }

        //======================================================================
        // Stage 7: Verify Coverage Reports Exist
        //======================================================================
        stage('Verify Coverage') {
            parallel {
                stage('Verify Backend Coverage') {
                    steps {
                        dir("${BACKEND_DIR}") {
                            script {
                                def coverageExists = fileExists('coverage/lcov.info')
                                if (coverageExists) {
                                    echo "âœ… Backend coverage report found"
                                    env.BACKEND_COVERAGE_EXISTS = 'true'
                                } else {
                                    echo "âš ï¸ WARNING: Backend coverage report missing!"
                                    echo "Add real tests with Jest/Mocha to generate coverage"
                                    echo "Pipeline will continue but SonarQube metrics will be incomplete"
                                    env.BACKEND_COVERAGE_EXISTS = 'false'
                                }
                            }
                        }
                    }
                }
                stage('Verify Frontend Coverage') {
                    steps {
                        dir("${FRONTEND_DIR}") {
                            script {
                                def coverageExists = fileExists('coverage/lcov.info')
                                if (coverageExists) {
                                    echo "âœ… Frontend coverage report found"
                                    env.FRONTEND_COVERAGE_EXISTS = 'true'
                                } else {
                                    echo "âš ï¸ WARNING: Frontend coverage report missing!"
                                    echo "Add real tests with Vitest/Jest to generate coverage"
                                    echo "Pipeline will continue but SonarQube metrics will be incomplete"
                                    env.FRONTEND_COVERAGE_EXISTS = 'false'
                                }
                            }
                        }
                    }
                }
            }
        }

        //======================================================================
        // Stage 8: SonarQube Analysis (Skips if not configured)
        //======================================================================
        stage('SonarQube Analysis') {
            steps {
                script {
                    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    echo "ğŸ” SONARQUBE CODE ANALYSIS"
                    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    
                    // Try to get SonarQube Scanner tool - skip gracefully if not configured
                    def scannerHome = null
                    try {
                        scannerHome = tool 'sonar-scanner'
                    } catch (Exception e) {
                        echo "âš ï¸ SonarQube Scanner tool not configured in Jenkins"
                        echo "To enable SonarQube analysis:"
                        echo "  1. Install SonarQube Scanner plugin"
                        echo "  2. Go to: Manage Jenkins â†’ Global Tool Configuration"
                        echo "  3. Add SonarQube Scanner with name 'sonar-scanner'"
                        echo "Skipping SonarQube analysis..."
                        env.SONAR_SKIPPED = 'true'
                        return
                    }
                    
                    // Run Backend Scan
                    def backendCoverageFlag = ''
                    if (env.BACKEND_COVERAGE_EXISTS == 'true') {
                        backendCoverageFlag = '-Dsonar.javascript.lcov.reportPaths=coverage/lcov.info'
                    }
                    
                    withSonarQubeEnv('SonarQube') {
                        dir("${BACKEND_DIR}") {
                            echo "ğŸ” Scanning Backend with SonarQube..."
                            sh """
                                ${scannerHome}/bin/sonar-scanner \
                                    -Dsonar.projectKey=shopdeploy-backend \
                                    -Dsonar.projectName="ShopDeploy Backend" \
                                    -Dsonar.sources=src \
                                    -Dsonar.exclusions=**/node_modules/**,**/coverage/** \
                                    -Dsonar.sourceEncoding=UTF-8 \
                                    ${backendCoverageFlag}
                            """
                        }
                        
                        // Run Frontend Scan
                        def frontendCoverageFlag = ''
                        if (env.FRONTEND_COVERAGE_EXISTS == 'true') {
                            frontendCoverageFlag = '-Dsonar.javascript.lcov.reportPaths=coverage/lcov.info'
                        }
                        
                        dir("${FRONTEND_DIR}") {
                            echo "ğŸ” Scanning Frontend with SonarQube..."
                            sh """
                                ${scannerHome}/bin/sonar-scanner \
                                    -Dsonar.projectKey=shopdeploy-frontend \
                                    -Dsonar.projectName="ShopDeploy Frontend" \
                                    -Dsonar.sources=src \
                                    -Dsonar.exclusions=**/node_modules/**,**/dist/** \
                                    -Dsonar.sourceEncoding=UTF-8 \
                                    ${frontendCoverageFlag}
                            """
                        }
                    }
                    
                    echo "âœ… SonarQube analysis completed"
                }
            }
        }

        //======================================================================
        // Stage 9: Quality Gate (Skips if SonarQube was skipped)
        //======================================================================
        stage('Quality Gate') {
            steps {
                script {
                    if (env.SONAR_SKIPPED == 'true') {
                        echo "âš ï¸ Skipping Quality Gate - SonarQube was not configured"
                        return
                    }
                    echo 'Waiting for SonarQube Quality Gate...'
                    timeout(time: 10, unit: 'MINUTES') {
                        waitForQualityGate abortPipeline: true
                    }
                }
            }
        }

        //======================================================================
        // Stage 10: Build Docker Images
        //======================================================================
        stage('Build Docker Images') {
            parallel {
                stage('Build Backend Image') {
                    steps {
                        echo "${env.ENV_EMOJI} Building backend Docker image for ${params.TARGET_ENVIRONMENT}..."
                        withCredentials([[
                            $class: 'AmazonWebServicesCredentialsBinding',
                            credentialsId: 'aws-credentials',
                            accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                            secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                        ]]) {
                            sh """
                                # Login to ECR for cache pull
                                aws ecr get-login-password --region ${AWS_REGION} | \
                                    docker login --username AWS --password-stdin ${ECR_REGISTRY}
                                
                                # Pull latest image for cache (ignore if not exists)
                                docker pull ${ECR_REGISTRY}/${ECR_BACKEND_REPO}:latest || true
                                
                                docker build \
                                    --cache-from ${ECR_REGISTRY}/${ECR_BACKEND_REPO}:latest \
                                    --tag shopdeploy-backend:${IMAGE_TAG} \
                                    --build-arg BUILD_DATE=\$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
                                    --build-arg VERSION=${IMAGE_TAG} \
                                    --build-arg BUILDKIT_INLINE_CACHE=1 \
                                    --file ${BACKEND_DIR}/Dockerfile \
                                    ${BACKEND_DIR}
                            """
                        }
                    }
                }

                stage('Build Frontend Image') {
                    steps {
                        echo "Building frontend Docker image for ${params.TARGET_ENVIRONMENT}..."
                        withCredentials([[
                            $class: 'AmazonWebServicesCredentialsBinding',
                            credentialsId: 'aws-credentials',
                            accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                            secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                        ]]) {
                            sh """
                                # Pull latest image for cache (ignore if not exists)
                                docker pull ${ECR_REGISTRY}/${ECR_FRONTEND_REPO}:latest || true
                                
                                echo "Using API URL: ${env.API_URL}"
                                
                                docker build \
                                    --cache-from ${ECR_REGISTRY}/${ECR_FRONTEND_REPO}:latest \
                                    --tag shopdeploy-frontend:${IMAGE_TAG} \
                                    --build-arg BUILD_DATE=\$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
                                    --build-arg VERSION=${IMAGE_TAG} \
                                    --build-arg VITE_API_URL=${env.API_URL} \
                                    --build-arg ENVIRONMENT=${params.TARGET_ENVIRONMENT} \
                                    --build-arg BUILDKIT_INLINE_CACHE=1 \
                                    --file ${FRONTEND_DIR}/Dockerfile \
                                    ${FRONTEND_DIR}
                            """
                        }
                    }
                }
            }
        }

        //======================================================================
        // Stage 11: Security Scan
        //======================================================================
        stage('Security Scan') {
            parallel {
                stage('Scan Backend Image') {
                    steps {
                        echo 'Scanning backend image for vulnerabilities...'
                        sh '''
                            if command -v trivy &> /dev/null; then
                                trivy image --severity HIGH,CRITICAL --exit-code 0 --format table shopdeploy-backend:${IMAGE_TAG} || true
                            else
                                echo "Trivy not available. Skipping security scan."
                            fi
                        '''
                    }
                }

                stage('Scan Frontend Image') {
                    steps {
                        echo 'Scanning frontend image for vulnerabilities...'
                        sh '''
                            if command -v trivy &> /dev/null; then
                                trivy image --severity HIGH,CRITICAL --exit-code 0 --format table shopdeploy-frontend:${IMAGE_TAG} || true
                            else
                                echo "Trivy not available. Skipping security scan."
                            fi
                        '''
                    }
                }
            }
        }

        //======================================================================
        // Stage 12: Push to ECR
        //======================================================================
        stage('Push to ECR') {
            steps {
                echo 'Pushing images to AWS ECR...'
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'aws-credentials',
                    accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                    secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                ]]) {
                    sh '''
                        # Login to ECR
                        aws ecr get-login-password --region ${AWS_REGION} | \
                            docker login --username AWS --password-stdin ${ECR_REGISTRY}
                    '''
                    
                    // Push backend with retry
                    retry(3) {
                        sh '''
                            docker tag shopdeploy-backend:${IMAGE_TAG} ${ECR_REGISTRY}/${ECR_BACKEND_REPO}:${IMAGE_TAG}
                            docker push ${ECR_REGISTRY}/${ECR_BACKEND_REPO}:${IMAGE_TAG}
                            echo "Backend pushed: ${ECR_REGISTRY}/${ECR_BACKEND_REPO}:${IMAGE_TAG}"
                        '''
                    }
                    
                    // Push frontend with retry
                    retry(3) {
                        sh '''
                            docker tag shopdeploy-frontend:${IMAGE_TAG} ${ECR_REGISTRY}/${ECR_FRONTEND_REPO}:${IMAGE_TAG}
                            docker push ${ECR_REGISTRY}/${ECR_FRONTEND_REPO}:${IMAGE_TAG}
                            echo "Frontend pushed: ${ECR_REGISTRY}/${ECR_FRONTEND_REPO}:${IMAGE_TAG}"
                        '''
                    }
                }
            }
        }

        //======================================================================
        // Stage 13: Save Image Tag
        //======================================================================
        stage('Save Image Tag') {
            steps {
                echo 'Saving image tag for CD pipeline...'
                script {
                    // Save to file for artifact
                    writeFile file: 'image-tag.txt', text: IMAGE_TAG
                    
                    // Save build metadata
                    def buildInfo = """
                    {
                        "imageTag": "${IMAGE_TAG}",
                        "buildNumber": "${BUILD_NUMBER}",
                        "gitCommit": "${GIT_COMMIT}",
                        "gitAuthor": "${env.GIT_AUTHOR}",
                        "gitMessage": "${env.GIT_COMMIT_MSG}",
                        "buildTime": "${new Date().format('yyyy-MM-dd HH:mm:ss')}",
                        "backendImage": "${ECR_REGISTRY}/${ECR_BACKEND_REPO}:${IMAGE_TAG}",
                        "frontendImage": "${ECR_REGISTRY}/${ECR_FRONTEND_REPO}:${IMAGE_TAG}"
                    }
                    """
                    writeFile file: 'build-info.json', text: buildInfo
                    
                    // Archive artifacts
                    archiveArtifacts artifacts: 'image-tag.txt,build-info.json', fingerprint: true
                    
                    // Optional: Store in AWS Parameter Store for cross-pipeline access
                    withCredentials([[
                        $class: 'AmazonWebServicesCredentialsBinding',
                        credentialsId: 'aws-credentials',
                        accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                        secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                    ]]) {
                        sh """
                            aws ssm put-parameter \
                                --name "/shopdeploy/latest-image-tag" \
                                --value "${IMAGE_TAG}" \
                                --type String \
                                --overwrite \
                                --region ${AWS_REGION} || echo "Failed to update Parameter Store"
                        """
                    }
                    
                    echo "Image tag saved: ${IMAGE_TAG}"
                }
            }
        }

        //======================================================================
        // Stage 14: Cleanup
        //======================================================================
        stage('Cleanup') {
            steps {
                echo 'Cleaning up local images...'
                sh """
                    docker rmi shopdeploy-backend:${IMAGE_TAG} || true
                    docker rmi shopdeploy-frontend:${IMAGE_TAG} || true
                    docker rmi ${ECR_REGISTRY}/${ECR_BACKEND_REPO}:${IMAGE_TAG} || true
                    docker rmi ${ECR_REGISTRY}/${ECR_FRONTEND_REPO}:${IMAGE_TAG} || true
                    docker image prune -f || true
                    echo "Cleanup completed"
                """
            }
        }
    }

    //==========================================================================
    // Post-Build Actions
    //==========================================================================
    post {
        success {
            script {
                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                echo "${env.ENV_EMOJI} CI PIPELINE SUCCESS"
                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                echo "Environment: ${params.TARGET_ENVIRONMENT.toUpperCase()}"
                echo "Build: #${BUILD_NUMBER}"
                echo "Image Tag: ${IMAGE_TAG}"
                echo "Duration: ${currentBuild.durationString}"
                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                
                // Slack notification (optional - skip if not configured)
                try {
                    slackSend(
                        channel: '#deployments',
                        color: 'good',
                        message: "${env.ENV_EMOJI} CI Build Success | ${params.TARGET_ENVIRONMENT.toUpperCase()} | Build #${BUILD_NUMBER} | Tag: ${IMAGE_TAG}"
                    )
                } catch (Exception e) {
                    echo "Slack notification skipped (not configured)"
                }
                
                // Trigger CD pipeline if enabled and exists
                if (params.TRIGGER_CD) {
                    try {
                        echo "ğŸš€ Triggering CD pipeline for ${params.TARGET_ENVIRONMENT.toUpperCase()}..."
                        build job: 'shopdeploy-cd',
                            parameters: [
                                string(name: 'IMAGE_TAG', value: IMAGE_TAG),
                                string(name: 'ENVIRONMENT', value: params.TARGET_ENVIRONMENT)
                            ],
                            wait: false  // Don't wait for CD to complete
                        echo "âœ… CD pipeline triggered successfully!"
                    } catch (Exception e) {
                        echo "âš ï¸ CD pipeline 'shopdeploy-cd' not found. Create the CD pipeline job first."
                        echo "Image tag ${IMAGE_TAG} is saved and can be used for manual deployment."
                    }
                } else {
                    echo "â„¹ï¸ CD pipeline trigger disabled. Manual deployment required."
                    echo "Use Image Tag: ${IMAGE_TAG}"
                }
            }
        }

        failure {
            script {
                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                echo "âŒ CI PIPELINE FAILED"
                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                echo "Environment: ${params.TARGET_ENVIRONMENT.toUpperCase()}"
                echo "Build: #${BUILD_NUMBER}"
                echo "Failed Stage: ${env.STAGE_NAME}"
                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                
                // Slack notification (optional - skip if not configured)
                try {
                    slackSend(
                        channel: '#deployments',
                        color: 'danger',
                        message: "âŒ CI Build FAILED | ${params.TARGET_ENVIRONMENT.toUpperCase()} | Build #${BUILD_NUMBER} | Stage: ${env.STAGE_NAME} | <${BUILD_URL}|View Logs>"
                    )
                } catch (Exception e) {
                    echo "Slack notification skipped (not configured)"
                }
            }
        }

        unstable {
            script {
                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                echo "âš ï¸ CI PIPELINE UNSTABLE"
                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                echo "Environment: ${params.TARGET_ENVIRONMENT.toUpperCase()}"
                echo "Build: #${BUILD_NUMBER}"
                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                
                try {
                    slackSend(
                        channel: '#deployments',
                        color: 'warning',
                        message: "âš ï¸ CI Build Unstable | ${params.TARGET_ENVIRONMENT.toUpperCase()} | Build #${BUILD_NUMBER} | Tag: ${IMAGE_TAG}"
                    )
                } catch (Exception e) {
                    echo "Slack notification skipped (not configured)"
                }
            }
        }

        always {
            archiveArtifacts artifacts: '**/coverage/**', allowEmptyArchive: true
            
            cleanWs(
                cleanWhenNotBuilt: false,
                deleteDirs: true,
                disableDeferredWipeout: true,
                notFailBuild: true
            )
        }
    }
}