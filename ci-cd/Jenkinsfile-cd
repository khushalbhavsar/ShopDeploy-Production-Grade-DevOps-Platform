/**
 * ============================================================================
 * ShopDeploy CD Pipeline (Build Once, Deploy Many)
 * ============================================================================
 * Responsibilities:
 * - Accept IMAGE_TAG from CI pipeline
 * - Deploy to target environment using Helm
 * - Production approval gate
 * - Run smoke tests
 * - Auto rollback on failure
 * ============================================================================
 * 
 * Golden Rule: Build once, deploy everywhere. Never rebuild for production.
 * 
 * ============================================================================
 */

pipeline {
    // Run on Jenkins agent with Docker, kubectl, and Helm installed
    agent any

    environment {
        // AWS Configuration
        AWS_REGION = 'us-east-1'
        AWS_ACCOUNT_ID = credentials('aws-account-id')

        // ECR Configuration
        ECR_REGISTRY = "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
        ECR_BACKEND_REPO = "shopdeploy-prod-backend"
        ECR_FRONTEND_REPO = "shopdeploy-prod-frontend"

        // EKS Configuration
        EKS_CLUSTER_NAME = 'shopdeploy-prod-eks'
        K8S_NAMESPACE = 'shopdeploy'
    }

    options {
        timeout(time: 30, unit: 'MINUTES')
        buildDiscarder(logRotator(numToKeepStr: '50'))
        timestamps()
    }

    parameters {
        string(
            name: 'IMAGE_TAG',
            defaultValue: '',
            description: 'Docker image tag to deploy (e.g., 42-a1b2c3d). Leave empty to use latest from Parameter Store.'
        )
        choice(
            name: 'ENVIRONMENT',
            choices: ['dev', 'staging', 'prod'],
            description: 'Target deployment environment'
        )
        booleanParam(
            name: 'SKIP_SMOKE_TESTS',
            defaultValue: false,
            description: 'Skip smoke tests after deployment'
        )
        booleanParam(
            name: 'DRY_RUN',
            defaultValue: false,
            description: 'Perform dry-run without actual deployment'
        )
    }

    stages {
        //======================================================================
        // Stage 1: Initialize
        //======================================================================
        stage('Initialize') {
            steps {
                echo 'ğŸš€ Initializing CD Pipeline...'
                script {
                    // Get IMAGE_TAG from parameter or Parameter Store
                    if (params.IMAGE_TAG?.trim()) {
                        env.DEPLOY_IMAGE_TAG = params.IMAGE_TAG.trim()
                        echo "ğŸ“¦ Using provided IMAGE_TAG: ${env.DEPLOY_IMAGE_TAG}"
                    } else {
                        echo "ğŸ“¦ Fetching latest IMAGE_TAG from Parameter Store..."
                        withCredentials([[
                            $class: 'AmazonWebServicesCredentialsBinding',
                            credentialsId: 'aws-credentials',
                            accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                            secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                        ]]) {
                            env.DEPLOY_IMAGE_TAG = sh(
                                script: """
                                    aws ssm get-parameter \
                                        --name "/shopdeploy/latest-image-tag" \
                                        --query 'Parameter.Value' \
                                        --output text \
                                        --region ${AWS_REGION}
                                """,
                                returnStdout: true
                            ).trim()
                        }
                        echo "ğŸ“¦ Retrieved IMAGE_TAG from Parameter Store: ${env.DEPLOY_IMAGE_TAG}"
                    }
                    
                    // Validate IMAGE_TAG
                    if (!env.DEPLOY_IMAGE_TAG || env.DEPLOY_IMAGE_TAG == 'null') {
                        error("âŒ IMAGE_TAG is required. Please provide a valid image tag.")
                    }
                    
                    // Set full image URLs
                    env.BACKEND_IMAGE = "${ECR_REGISTRY}/${ECR_BACKEND_REPO}:${env.DEPLOY_IMAGE_TAG}"
                    env.FRONTEND_IMAGE = "${ECR_REGISTRY}/${ECR_FRONTEND_REPO}:${env.DEPLOY_IMAGE_TAG}"
                    
                    echo """
                    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
                    â•‘  ğŸ“‹ DEPLOYMENT CONFIGURATION                              â•‘
                    â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
                    â•‘  Environment: ${params.ENVIRONMENT}                       
                    â•‘  Image Tag: ${env.DEPLOY_IMAGE_TAG}                       
                    â•‘  Backend: ${env.BACKEND_IMAGE}                            
                    â•‘  Frontend: ${env.FRONTEND_IMAGE}                          
                    â•‘  Dry Run: ${params.DRY_RUN}                               
                    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    """
                }
            }
        }

        //======================================================================
        // Stage 2: Verify Images Exist
        //======================================================================
        stage('Verify Images') {
            steps {
                echo 'ğŸ” Verifying images exist in ECR...'
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'aws-credentials',
                    accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                    secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                ]]) {
                    sh '''
                        # Login to ECR
                        aws ecr get-login-password --region ${AWS_REGION} | \
                            docker login --username AWS --password-stdin ${ECR_REGISTRY}
                        
                        # Verify backend image exists
                        echo "ğŸ” Checking backend image..."
                        aws ecr describe-images \
                            --repository-name ${ECR_BACKEND_REPO} \
                            --image-ids imageTag=${DEPLOY_IMAGE_TAG} \
                            --region ${AWS_REGION} > /dev/null || \
                            { echo "âŒ Backend image not found: ${DEPLOY_IMAGE_TAG}"; exit 1; }
                        echo "âœ… Backend image verified"
                        
                        # Verify frontend image exists
                        echo "ğŸ” Checking frontend image..."
                        aws ecr describe-images \
                            --repository-name ${ECR_FRONTEND_REPO} \
                            --image-ids imageTag=${DEPLOY_IMAGE_TAG} \
                            --region ${AWS_REGION} > /dev/null || \
                            { echo "âŒ Frontend image not found: ${DEPLOY_IMAGE_TAG}"; exit 1; }
                        echo "âœ… Frontend image verified"
                    '''
                }
            }
        }

        //======================================================================
        // Stage 3: Production Approval
        //======================================================================
        stage('Production Approval') {
            when {
                expression { params.ENVIRONMENT == 'prod' && !params.DRY_RUN }
            }
            steps {
                script {
                    echo 'â³ Waiting for production deployment approval...'
                    
                    def approvalMessage = """
                    ğŸš€ PRODUCTION DEPLOYMENT REQUEST
                    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    Image Tag: ${env.DEPLOY_IMAGE_TAG}
                    Backend: ${env.BACKEND_IMAGE}
                    Frontend: ${env.FRONTEND_IMAGE}
                    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    
                    âš ï¸ This will deploy to PRODUCTION.
                    Please review and approve.
                    """
                    
                    echo approvalMessage
                    
                    // Send Slack notification for approval request (optional)
                    try {
                        slackSend(
                            channel: '#deployments',
                            color: 'warning',
                            message: "ğŸ”” Production deployment approval needed | Tag: ${env.DEPLOY_IMAGE_TAG} | <${BUILD_URL}input|Approve/Reject>"
                        )
                    } catch (Exception e) {
                        echo "âš ï¸ Slack notification skipped (not configured)"
                    }
                    
                    timeout(time: 30, unit: 'MINUTES') {
                        input(
                            message: "Deploy ${env.DEPLOY_IMAGE_TAG} to PRODUCTION?",
                            ok: 'Approve Deployment',
                            submitter: 'admin,devops-team',
                            submitterParameter: 'APPROVER'
                        )
                    }
                    
                    echo "âœ… Production deployment approved by ${env.APPROVER}"
                    
                    try {
                        slackSend(
                            channel: '#deployments',
                            color: 'good',
                            message: "âœ… Production deployment approved by ${env.APPROVER} | Tag: ${env.DEPLOY_IMAGE_TAG}"
                        )
                    } catch (Exception e) {
                        echo "âš ï¸ Slack notification skipped (not configured)"
                    }
                }
            }
        }

        //======================================================================
        // Stage 4: Capture Current State (for Rollback)
        //======================================================================
        stage('Capture Rollback Info') {
            when {
                expression { !params.DRY_RUN }
            }
            steps {
                echo 'ğŸ“¸ Capturing current deployment state for rollback...'
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'aws-credentials',
                    accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                    secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                ]]) {
                    script {
                        sh '''
                            # Configure kubectl for EKS
                            aws eks update-kubeconfig --region ${AWS_REGION} --name ${EKS_CLUSTER_NAME}
                        '''
                        
                        // Get current Helm release revisions
                        env.BACKEND_REVISION = sh(
                            script: "helm history shopdeploy-backend -n ${K8S_NAMESPACE} --max 1 -o json 2>/dev/null | jq -r '.[0].revision' || echo '0'",
                            returnStdout: true
                        ).trim()
                        
                        env.FRONTEND_REVISION = sh(
                            script: "helm history shopdeploy-frontend -n ${K8S_NAMESPACE} --max 1 -o json 2>/dev/null | jq -r '.[0].revision' || echo '0'",
                            returnStdout: true
                        ).trim()
                        
                        echo "ğŸ“‹ Current backend revision: ${env.BACKEND_REVISION}"
                        echo "ğŸ“‹ Current frontend revision: ${env.FRONTEND_REVISION}"
                    }
                }
            }
        }

        //======================================================================
        // Stage 5: Deploy to Environment
        //======================================================================
        stage('Deploy') {
            steps {
                echo "ğŸš€ Deploying to ${params.ENVIRONMENT}..."
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'aws-credentials',
                    accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                    secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                ]]) {
                    script {
                        def helmArgs = params.DRY_RUN ? '--dry-run' : ''
                        def valuesFile = "values-${params.ENVIRONMENT}.yaml"
                        
                        sh """
                            # Configure kubectl for EKS
                            aws eks update-kubeconfig --region ${AWS_REGION} --name ${EKS_CLUSTER_NAME}
                            
                            # Verify tools
                            echo "ğŸ“‹ Tool versions:"
                            kubectl version --client --short || kubectl version --client
                            helm version --short
                            
                            # Create namespace if not exists
                            kubectl create namespace ${K8S_NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -
                            
                            # Deploy backend
                            echo "ğŸ“¦ Deploying backend..."
                            helm upgrade --install shopdeploy-backend ./helm/backend \
                                --namespace ${K8S_NAMESPACE} \
                                --values ./helm/backend/${valuesFile} \
                                --set image.repository=${ECR_REGISTRY}/${ECR_BACKEND_REPO} \
                                --set image.tag=${DEPLOY_IMAGE_TAG} \
                                --set global.environment=${params.ENVIRONMENT} \
                                --wait \
                                --timeout 10m \
                                ${helmArgs}
                            
                            # Deploy frontend
                            echo "ğŸ¨ Deploying frontend..."
                            helm upgrade --install shopdeploy-frontend ./helm/frontend \
                                --namespace ${K8S_NAMESPACE} \
                                --values ./helm/frontend/${valuesFile} \
                                --set image.repository=${ECR_REGISTRY}/${ECR_FRONTEND_REPO} \
                                --set image.tag=${DEPLOY_IMAGE_TAG} \
                                --set global.environment=${params.ENVIRONMENT} \
                                --wait \
                                --timeout 10m \
                                ${helmArgs}
                            
                            echo "âœ… Deployment completed"
                        """
                    }
                }
            }
        }

        //======================================================================
        // Stage 6: Smoke Tests
        //======================================================================
        stage('Smoke Tests') {
            when {
                expression { !params.SKIP_SMOKE_TESTS && !params.DRY_RUN }
            }
            steps {
                echo 'ğŸ”¬ Running smoke tests...'
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'aws-credentials',
                    accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                    secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                ]]) {
                    sh '''
                        # Configure kubectl
                        aws eks update-kubeconfig --region ${AWS_REGION} --name ${EKS_CLUSTER_NAME}
                        
                        echo "ğŸ“‹ Checking deployment status..."
                        
                        # Check pod status
                        echo "ğŸ” Pod Status:"
                        kubectl get pods -n ${K8S_NAMESPACE} -o wide
                        
                        # Wait for backend rollout
                        echo "â³ Waiting for backend rollout..."
                        kubectl rollout status deployment/shopdeploy-backend -n ${K8S_NAMESPACE} --timeout=300s
                        
                        # Wait for frontend rollout
                        echo "â³ Waiting for frontend rollout..."
                        kubectl rollout status deployment/shopdeploy-frontend -n ${K8S_NAMESPACE} --timeout=300s
                        
                        # Get service endpoints
                        echo "ğŸŒ Service Endpoints:"
                        kubectl get svc -n ${K8S_NAMESPACE}
                        
                        # Get ingress
                        echo "ğŸšª Ingress:"
                        kubectl get ingress -n ${K8S_NAMESPACE} || echo "No ingress configured"
                        
                        # Verify pods are running
                        echo "ğŸ¥ Health check..."
                        BACKEND_READY=$(kubectl get pods -n ${K8S_NAMESPACE} -l app=shopdeploy-backend -o jsonpath='{.items[*].status.conditions[?(@.type=="Ready")].status}')
                        FRONTEND_READY=$(kubectl get pods -n ${K8S_NAMESPACE} -l app=shopdeploy-frontend -o jsonpath='{.items[*].status.conditions[?(@.type=="Ready")].status}')
                        
                        if [[ "$BACKEND_READY" == *"True"* ]] && [[ "$FRONTEND_READY" == *"True"* ]]; then
                            echo "âœ… All pods are healthy"
                        else
                            echo "âŒ Some pods are not ready"
                            kubectl describe pods -n ${K8S_NAMESPACE}
                            exit 1
                        fi
                        
                        echo "âœ… Smoke tests passed"
                    '''
                }
            }
        }

        //======================================================================
        // Stage 7: Integration Tests (Non-Prod Only)
        //======================================================================
        stage('Integration Tests') {
            when {
                expression { params.ENVIRONMENT != 'prod' && !params.DRY_RUN }
            }
            steps {
                echo 'ğŸ§ª Running integration tests...'
                script {
                    def integrationTestFile = "shopdeploy-backend/tests/integration.test.js"
                    if (fileExists(integrationTestFile)) {
                        dir("shopdeploy-backend") {
                            sh 'npm run test:integration || echo "âš ï¸ Some integration tests failed"'
                        }
                    } else {
                        echo 'â„¹ï¸ No integration tests found, skipping...'
                    }
                }
            }
        }
    }

    //==========================================================================
    // Post-Build Actions
    //==========================================================================
    post {
        success {
            script {
                if (params.DRY_RUN) {
                    echo "âœ… Dry run completed successfully"
                } else {
                    echo """
                    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
                    â•‘  âœ… CD PIPELINE COMPLETED SUCCESSFULLY                    â•‘
                    â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
                    â•‘  Environment: ${params.ENVIRONMENT}                       
                    â•‘  Image Tag: ${env.DEPLOY_IMAGE_TAG}                       
                    â•‘  Duration: ${currentBuild.durationString}                 
                    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    """
                    
                    try {
                        slackSend(
                            channel: '#deployments',
                            color: 'good',
                            message: "âœ… Deployed to ${params.ENVIRONMENT} | Tag: ${env.DEPLOY_IMAGE_TAG} | Duration: ${currentBuild.durationString}"
                        )
                    } catch (Exception e) {
                        echo "âš ï¸ Slack notification skipped (not configured)"
                    }
                }
            }
        }

        failure {
            script {
                echo """
                â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
                â•‘  âŒ CD PIPELINE FAILED                                    â•‘
                â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
                â•‘  Environment: ${params.ENVIRONMENT}                       
                â•‘  Image Tag: ${env.DEPLOY_IMAGE_TAG}                       
                â•‘  Stage: ${env.STAGE_NAME}                                 
                â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                """
                
                // Auto rollback for production
                if (params.ENVIRONMENT == 'prod' && !params.DRY_RUN) {
                    echo 'ğŸš¨ Production deployment failed! Initiating automatic rollback...'
                    
                    try {
                        withCredentials([[
                            $class: 'AmazonWebServicesCredentialsBinding',
                            credentialsId: 'aws-credentials',
                            accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                            secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
                        ]]) {
                            sh '''
                                aws eks update-kubeconfig --region ${AWS_REGION} --name ${EKS_CLUSTER_NAME}
                                
                                echo "ğŸ”„ Rolling back backend..."
                                helm rollback shopdeploy-backend ${BACKEND_REVISION} -n ${K8S_NAMESPACE} --wait --timeout 5m || true
                                
                                echo "ğŸ”„ Rolling back frontend..."
                                helm rollback shopdeploy-frontend ${FRONTEND_REVISION} -n ${K8S_NAMESPACE} --wait --timeout 5m || true
                                
                                echo "âœ… Rollback completed"
                                kubectl get pods -n ${K8S_NAMESPACE}
                            '''
                        }
                        
                        try {
                            slackSend(
                                channel: '#deployments',
                                color: 'warning',
                                message: "ğŸ”„ Auto-rollback completed for ${params.ENVIRONMENT} | Failed Tag: ${env.DEPLOY_IMAGE_TAG}"
                            )
                        } catch (Exception slackErr) {
                            echo "âš ï¸ Slack notification skipped (not configured)"
                        }
                    } catch (Exception e) {
                        echo "âŒ Rollback failed: ${e.message}"
                        try {
                            slackSend(
                                channel: '#deployments',
                                color: 'danger',
                                message: "ğŸš¨ CRITICAL: Rollback FAILED for ${params.ENVIRONMENT} | Manual intervention required!"
                            )
                        } catch (Exception slackErr) {
                            echo "âš ï¸ Slack notification skipped (not configured)"
                        }
                    }
                }
                
                try {
                    slackSend(
                        channel: '#deployments',
                        color: 'danger',
                        message: "âŒ Deploy FAILED: ${params.ENVIRONMENT} | Tag: ${env.DEPLOY_IMAGE_TAG} | Stage: ${env.STAGE_NAME} | <${BUILD_URL}|View Logs>"
                    )
                } catch (Exception e) {
                    echo "âš ï¸ Slack notification skipped (not configured)"
                }
            }
        }

        aborted {
            script {
                echo 'ğŸ›‘ CD Pipeline was aborted'
                try {
                    slackSend(
                        channel: '#deployments',
                        color: 'warning',
                        message: "ğŸ›‘ Deployment aborted: ${params.ENVIRONMENT} | Tag: ${env.DEPLOY_IMAGE_TAG}"
                    )
                } catch (Exception e) {
                    echo "âš ï¸ Slack notification skipped (not configured)"
                }
            }
        }

        always {
            cleanWs(
                cleanWhenNotBuilt: false,
                deleteDirs: true,
                disableDeferredWipeout: true,
                notFailBuild: true
            )
        }
    }
}
